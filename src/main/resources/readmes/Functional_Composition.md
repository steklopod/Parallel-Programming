## Композиция функций и for-comprehensions

Механизм обратного вызова, который мы показали, является достаточным для объединения будущих результатов с последующими 
вычислениями. Однако это иногда неудобно и приводит к громоздкому коду. Мы покажем это на примере. _Предположим, у нас 
есть API для взаимодействия с валютой. Предположим, мы хотим купить доллары США, но только тогда, когда это выгодно. 
Сначала мы покажем, как это можно сделать с помощью обратных вызовов:_

```scala
    val ставкаКурса = Future {
      connection.getCurrentValue(USD)
    }
    
    ставкаКурса foreach { котировка =>
      val покупка = Future {
        if (рентабельно(котировка)) connection.buy(количество, котировка)
        else throw new Exception("не прибыльно")
      }
    
      покупка foreach { _ =>
        println("Куплено " + количество + " USD")
      }
    }
```

Мы начинаем с создания будущего `ставкаКурса`, которое получает текущий обменный курс. После того, как это значение будет 
получено с сервера, и будущее будет успешно завершено, вычисление продолжается в обратном вызове `foreach`, и мы готовы 
решить, покупать или нет. Поэтому мы создаем еще одно будущее `покупка`, которое принимает решение о покупке, только если 
это выгодно сделать, а затем отправляет запрос на покупку. Наконец, как только покупка будет завершена, мы печатаем сообщение уведомления 
на стандартный вывод.

Это работает, но неудобно по двум причинам:

* Во-первых, мы должны использовать `foreach` и вставлять в нее второе будущее 
покупки. Представьте себе, что после завершения покупки мы хотим продать другую валюту. Мы должны были бы повторить этот
 шаблон в обратном вызове `foreach`, делая код чрезмерным и громоздким.

* Во-вторых, будущее `покупка` не входит в сферу действия с остальной частью кода - на него можно воздействовать только 
из-за обратного вызова `foreach`. Это означает, что другие части приложения не видят будущего покупки и не могут 
зарегистрировать другой обратный вызов `foreach`, например, чтобы продать другую валюту.

По этим двум причинам фьючерсы предоставляют комбинаторы, которые обеспечивают более простой состав. Одним из основных 
комбинаторов является `map`, которая, учитывая будущее и функцию отображения для значения будущего, создает новое будущее, 
которое будет завершено с отображенным значением после успешного завершения первоначального будущего. Вы можете рассуждать 
о сопоставлении фьючерсов так же, как вы думаете о сопоставлении коллекций.

Давайте перепишем предыдущий пример, используя `map`-комбинатор:

```scala
    val ставкаКурса = Future {
      connection.getCurrentValue(USD)
    }
    
    val покупка = ставкаКурса map { котировка =>
      if (рентабельно(котировка)) connection.buy(количество, котировка)
      else throw new Exception("not profitable")
    }
    
    покупка foreach { _ =>
      println("покупка " + количество + " USD")
    }
```

Используя `map` на `ставкаКурса`, мы устранили один обратный вызов `foreach` и, что более важно, вложенность. Если мы сейчас 
решаем продать какую-либо другую валюту, достаточно снова использовать `map` при покупке.

_Но что произойдет, если `рентабельно` возвращает `false`, и, следовательно, вызывает исключение?_ В этом случае покупка 
не удалась с этим исключением. Кроме того, представьте, что соединение было нарушено и что `getCurrentValue` выбрал исключение, 
не получив `ставкаКурса`. В этом случае у нас не было бы никакой ценности для сопоставления, поэтому покупка будет 
автоматически сбой с тем же исключением, что и `ставкаКурса`.

В заключение, если исходное будущее завершено успешно, то возвращаемое будущее будет завершено с отображенным значением 
из первоначального будущего. Если функция отображения генерирует исключение, то будущее будет завершено с этим исключением. 
Если исходное будущее выходит из строя с исключением, то возвращаемое будущее также содержит одно и то же исключение. 
Эта семантика распространения исключений присутствует и в остальных комбинаторах.

Одной из целей дизайна фьючерсов было обеспечение их использования в целях понимания. По этой причине фьючерсы также имеют 
комбинаторы `flatMap` и `withFilter`. Метод `flatMap` принимает функцию, которая отображает значение в новое будущее `g`, 
а затем возвращает будущее, которое завершается после завершения `g`.

Предположим, что мы хотим обменять доллары США на швейцарские франки (CHF). Мы должны получить котировки для обеих валют, 
а затем принять решение о покупке на основе обоих котировок. Ниже приведен пример использования `flatMap` и `withFilter`
 для понимания:

```scala
    val usdКотировка = Future { connection.getCurrentValue(USD) }
    val chfКотировка = Future { connection.getCurrentValue(CHF) }
    
    val покупка = for {
      usd <- usdКотировка
      chf <- chfКотировка
      if рентабельно(usd, chf)
    } yield connection.buy(количество, chf)
    
    покупка foreach { _ =>
      println("покупка " + количество + " CHF")
    }
```

Будущее покупки завершается только после завершения обоих `usdКотировка` и `chfКотировка` - это зависит от значений обоих этих 
фьючерсов, поэтому его собственное вычисление не может начаться раньше.


```scala
    val покупка = usdКотировка flatMap {
      usd =>
      chfКотировка
        .withFilter(chf => рентабельно(usd, chf))
        .map(chf => connection.buy(количество, chf))
    }
```

это немного сложнее понять, но давайте проанализируем, чтобы лучше понять операцию `flatMap`. Операция 
`flatMap` отображает свое значение в другое будущее. Как только это другое будущее будет завершено его стоимостью. 
В нашем примере `flatMap` использует значение будущего `usdКотировка` для сопоставления 
значения `chfКотировка` в третьем будущем, которое отправляет запрос на покупку определенной суммы швейцарских франков. 
В результате будущая покупка будет завершена только после того, как это третье будущее вернется.

Это может быть ошеломляющим, но, к счастью, операция `flatMap` редко используется за пределами понятий, которые проще в 
использовании и понимании.

Комбинатор фильтров создает новое будущее, которое содержит значение исходного будущего, только если оно удовлетворяет 
некоторым предикатам. В противном случае новое будущее не выполняется с помощью исключения `NoSuchElementException`. 
Для фьючерсных вызовов фильтр имеет тот же эффект, что и вызов `withFilter`.

Связь между комбинатором сбора и фильтра аналогична взаимосвязи этих методов в API коллекций.

Поскольку признак Будущего может концептуально содержать два типа значений (результаты вычислений и исключения), существует 
необходимость в комбинаторах, которые обрабатывают исключения.

Предположим, что на основе `ставкаКурса` мы решаем купить определенную сумму. Метод `connection.buy` принимает сумму для 
покупки и ожидаемую цену. Он возвращает купленную сумму. Если цитата изменилась в то же время, она выкинет `КотировкаChangedException`
 и ничего не будет покупать. Если мы хотим, чтобы наше будущее содержало `0` вместо исключения, мы используем комбинатор 
 восстановления (`recover`):
 
 ```scala
    val покупка: Future[Int] = ставкаКурса map {
      котировка => connection.buy(количество, котировка)
    } recover {
      case КотировкаChangedException() => 0
    }
 ```
 
* Комбинатор `recover` создает новое будущее, которое имеет тот же результат, что и исходное будущее, если оно будет выполнено 
успешно. Если это не так, то аргумент частичной функции применяется к `Throwable`, который не смог выполнить первоначальное 
будущее. Если он сопоставляет значение `Throwable` с некоторым значением, то новое будущее успешно завершается с этим 
значением. Если частичная функция не определена на `Throwable`, то полученное будущее не будет выполнено с тем же `Throwable`.

* Комбинатор `recoverWith` создает новое будущее, которое имеет тот же результат, что и исходное будущее, если оно успешно 
завершено. В противном случае частичная функция применяется к `Throwable`, которая не удалась изначально. Если он 
отображает `Throwable` в какое-то будущее, то это будущее завершается результатом этого будущего. Его отношение к 
восстановлению аналогично соотношению `flatMap` к отображению.

* Комбинатор `fallbackTo` создает новое будущее, которое содержит результат этого будущего, если оно было успешно завершено,
 или иначе успешный результат аргумента в будущем. В случае, если и будущее, и будущее аргументов потерпят неудачу, новое 
 будущее завершается за исключением этого будущего, как в следующем примере, который пытается напечатать стоимость доллара 
 США, но печатает значение швейцарского франка в случае, если он не получить значение в долларах:
 
 ```scala
    val usdКотировка = Future {
      connection.getCurrentValue(USD)
    } map {
      usd => "Value: " + usd + "$"
    }
    val chfКотировка = Future {
      connection.getCurrentValue(CHF)
    } map {
      chf => "Value: " + chf + "CHF"
    }
    
    val anyКотировка = usdКотировка fallbackTo chfКотировка
    
    anyКотировка foreach { println(_) }
 ```
 
Комбинатор `andThen` используется исключительно для побочных целей. Он возвращает новое будущее с точно таким же результатом, 
как и текущее будущее, независимо от того, произошло ли текущее будущее или нет. Как только текущее будущее будет завершено 
с результатом, будет вызвано замыкание, соответствующее `andThen`, и затем новое будущее будет завершено с тем же 
результатом, что и в этом будущем. Это гарантирует, что заказываются несколько вызовов `andThen`, как в следующем 
примере, который хранит последние сообщения из социальной сети в изменяемый набор и затем отображает все сообщения на экран:

 ```scala
    val allposts = mutable.Set[String]()
    
    Future {
      session.getRecentPosts
    } andThen {
      case Success(posts) => allposts ++= posts
    } andThen {
      case _ =>
      clearAll()
      for (post <- allposts) render(post)
    }
 ```
 Таким образом, комбинаторы по фьючерсам являются чисто функциональными. Каждый комбинатор возвращает новое будущее, которое 
 связано с будущим, из которого оно было получено.
 
Понимание выше описано в:

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Parallel-Programming/blob/master/readme.md)
