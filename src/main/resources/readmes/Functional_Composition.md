## Композиция функций и for-comprehensions

Механизм обратного вызова, который мы показали, является достаточным для объединения будущих результатов с последующими 
вычислениями. Однако это иногда неудобно и приводит к громоздкому коду. Мы покажем это на примере. _Предположим, у нас 
есть API для взаимодействия с валютой. Предположим, мы хотим купить доллары США, но только тогда, когда это выгодно. 
Сначала мы покажем, как это можно сделать с помощью обратных вызовов:_

```scala
    val ставкаКурса = Future {
      connection.getCurrentValue(USD)
    }
    
    ставкаКурса foreach { котировка =>
      val покупка = Future {
        if (isProfitable(котировка)) connection.buy(количество, котировка)
        else throw new Exception("не прибыльно")
      }
    
      покупка foreach { _ =>
        println("Куплено " + количество + " USD")
      }
    }
```

Мы начинаем с создания будущего `ставкаКурса`, которое получает текущий обменный курс. После того, как это значение будет 
получено с сервера, и будущее будет успешно завершено, вычисление продолжается в обратном вызове `foreach`, и мы готовы 
решить, покупать или нет. Поэтому мы создаем еще одну будущую `покупка`, которая принимает решение о покупке, только если 
это выгодно сделать, а затем отправляет запрос. Наконец, как только покупка будет завершена, мы печатаем сообщение уведомления 
на стандартный вывод.

Это работает, но неудобно по двум причинам. Во-первых, мы должны использовать `foreach` и вставлять в нее второе будущее 
покупки. Представьте себе, что после завершения покупки мы хотим продать другую валюту. Мы должны были бы повторить этот
 шаблон в обратном вызове `foreach`, делая код чрезмерно с отступом, громоздким и трудноразрешимым.

Во-вторых, будущее `покупка` не входит в сферу действия с остальной частью кода - на него можно воздействовать только 
из-за обратного вызова `foreach`. Это означает, что другие части приложения не видят будущего покупки и не могут 
зарегистрировать другой обратный вызов `foreach`, например, чтобы продать другую валюту.

По этим двум причинам фьючерсы предоставляют комбинаторы, которые обеспечивают более простой состав. Одним из основных 
комбинаторов является `map`, которая, учитывая будущее и функцию отображения для значения будущего, создает новое будущее, 
которое будет завершено с отображенным значением после успешного завершения первоначального будущего. Вы можете рассуждать 
о сопоставлении фьючерсов так же, как вы думаете о сопоставлении коллекций.

Давайте перепишем предыдущий пример, используя `map`-комбинатор:

```scala
    val ставкаКурса = Future {
      connection.getCurrentValue(USD)
    }
    
    val покупка = ставкаКурса map { quote =>
      if (isProfitable(quote)) connection.buy(amount, quote)
      else throw new Exception("not profitable")
    }
    
    покупка foreach { _ =>
      println("покупка " + amount + " USD")
    }
```



_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Parallel-Programming/blob/master/readme.md)
