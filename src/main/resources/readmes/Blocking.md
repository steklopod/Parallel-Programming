## Блокировка (Blocking)

Фьючерсы обычно асинхронны и не блокируют основные потоки выполнения. Однако в некоторых случаях потоки необходимо блокировать. 
Мы различаем две формы блокировки потока выполнения: 
вызов произвольного кода, который блокирует поток из будущего 
и блокирует его из другого будущего, ожидая, пока это будущее не будет завершено.

### Блокирование внутри будущего (Blocking inside a Future)

Как видно из глобального `ExecutionContext`, можно уведомить `ExecutionContext` блокирующего вызова с помощью блокирующей 
конструкции. Однако реализация выполняется по усмотрению `ExecutionContext`. Хотя некоторые `ExecutionContext`, такие 
как `ExecutionContext.global`, реализуют блокировку с помощью `ManagedBlocker`, некоторые контексты выполнения, такие 
как фиксированный пул потоков:

```scala
    ExecutionContext.fromExecutor(Executors.newFixedThreadPool(x))
```

ничего не сделает, как показано ниже:

```scala
    implicit val ec = ExecutionContext.fromExecutor( Executors.newFixedThreadPool(4) )
    Future {
      blocking { blockingStuff() }
    }
```

Имеет тот же эффект, что и

```scala
    Future { blockingStuff() }
```

Блокирующий код может также генерировать исключение. В этом случае исключение отправляется вызывающему.

### Блокирование вне будущего (Blocking outside the Future)

Как упоминалось ранее, блокирование будущего сильно не поощряется ради эффективности и предотвращения взаимоблокировок. 
Обратные вызовы и комбинаторы на фьючерсах являются предпочтительным способом использования их результатов. Однако блокировка 
может потребоваться в определенных ситуациях и поддерживается API фьючерсов и обещаний.

В приведенном выше примере торговли валютой одно место для блокировки находится в конце приложения, чтобы убедиться, что 
все фьючерсы завершены. Вот пример того, как блокировать результат будущего:

```scala
    import scala.concurrent._
    import scala.concurrent.duration._
    
    def main(args: Array[String]) {
      val rateQuote = Future {
        connection.getCurrentValue(USD)
      }
    
      val purchase = rateQuote map { quote =>
        if (isProfitable(quote)) connection.buy(amount, quote)
        else throw new Exception("not profitable")
      }
    
      Await.result(purchase, 0 nanos)
    }
```

В случае неудачи в будущем вызывающая сторона отправляет исключение, с которым не удалось выполнить будущее. Это включает
 в себя неудачную блокировку прогноза на нем, что приводит к выдаче исключения `NoSuchElementException`, если исходное 
 будущее завершено успешно.

Кроме того, вызов `Await.ready` ждет, пока будущее не будет завершено, но не получит результат. Точно так же вызов этого 
метода не будет генерировать исключение, если будущее не удалось.

Будущая черта реализует свойство `Awaitable` с помощью методов `ready()` и `result()`. Эти методы не могут быть вызваны 
непосредственно клиентами - они могут быть вызваны только контекстом выполнения.


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Parallel-Programming/blob/master/readme.md)
