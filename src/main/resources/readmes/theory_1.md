### Эффект задержки (Latency as an effect)


Чтение из памяти занимает много времени. И отправка пакета из Европы и обратно занимает еще больше времени. Но на этот раз 
это выражается в наносекундах или микросекундах, что не очень интуитивно понятно для людей. 

![alt text](https://github.com/steklopod/Timely-Effects/blob/master/src/main/resources/images/timings_on_tipical_ops_on_typical_pc.png "time of ops")

Итак, давайте посмотрим на таблицу, в которой указывается время, когда различные операции выполняются на компьютере. 
_Обратите внимание, что эти времена будут меняться, потому что компьютеры меняются, поэтому возьмите это как приблизительное 
предположение._ Итак, возьмем типичную инструкцию, одну нано-секунду. Но давайте посмотрим на этот показатель, когда мы будем 
читать из памяти, так что это 250 000 наносекунд. И отправка пакета из США в Европу занимает около 150 миллисекунд. 
И обратите внимание, что многие из этих времен ограничены скоростью света. 
Я не до конца понимаю, что означает 150 миллисекунд или что означает 1 наносекунда. 
Итак, давайте возьмем эти цифры и **1 наносекунду и превратим это в секунду**, тогда 
мы сможем вычислить недели, месяцы и годы. Хорошо, потому что эта вещь все еще читается из памяти и занимает 
50 000 наносекунд. Какая разница? Хорошо, так что **давайте немного изменим эти цифры во что-то, что мы, люди, можем понять**.

Таким образом, одна наносекунда становится одной секундой, и тогда мы превратим это в дни и часы. Теперь мы получаем гораздо лучшую картину.
**С точки зрения человеческих временных рамок, чтение 1 мегабайта из памяти занимает около 3 дней**.
Таким образом, это походит на отправку ваших детей, чтобы сделать некоторые продукты, и это занимает 3 дня. Они должны 
отправиться на лошади в следующую деревню, получить продукты и вернуться. И, конечно, это все равно может потерпеть неудачу. 
Поэтому, когда вы ведете свою лошадь в следующую деревню, могут быть бандиты, которые нападают на вас. Таким образом, 
это не только требует времени, но и может потерпеть неудачу. Но в предыдущих лекциях мы имели дело с провалом. Но это 
еще хуже. Если вы посмотрите на отправку пакета из США в Европу и обратно, то в человеческие времена это занимает 5 лет.

![alt text](https://github.com/steklopod/Timely-Effects/blob/master/src/main/resources/images/send_to_europe.png "send_to_europe")

Таким образом, под этой простой программой была скрыта какая-то огромная латентность (задержка), какое-то огромное время, которое 
потребовалось для этого вычисления. И это не было видно в типе, поэтому давайте сделаем это снова видимым в типе. Потому 
что мы не хотим, чтобы это чтение из памяти блокировалось в течение 3 лет, а затем, в течение 3 дней извините. И затем 
отправка пакета в Европу и обратно будет заблокирована на 5 лет и будет продолжаться только тогда, когда не будет никаких 
исключений. Если вы посмотрите в реальной жизни, когда мы общаемся с людьми, представьте, что вы зададите вопрос человеку, 
и потребуется 5 лет, прежде чем вы получите ответ. Вы не подождете 5 лет. Что бы вы сделали? Ну, что бы я сделал, я бы 
дал этому человеку самопринятое письмо. Я бы сказал, вот вопрос, я знаю, вам требуется 5 лет, чтобы вы могли ответить на 
него. Как только у вас появится ответ, вы просто положите ответ в этот конверт, и вы вернете его мне.

Эта идея в информатике называется [обратным вызовом (callback)](https://ru.wikipedia.org/wiki/Callback_(программирование)). 
И это именно тот механизм, который мы будем использовать. Поэтому, если вычисление занимает много времени, мы собираемся 
ввести тип где вы можете зарегистрировать обратный вызов, который будет вызываться после завершения этого вычисления. И 
снова это вычисление может завершиться успешно или с исключением.

[=> Монада Future[T]](https://github.com/steklopod/Timely-Effects/blob/master/src/main/resources/readmes/Future.md)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Timely-Effects/blob/master/readme.md)