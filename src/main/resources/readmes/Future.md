## Монада Будущее (Future)

`Future` - это [монада](https://ru.wikipedia.org/wiki/Монада_(программирование)) объект, имеющий значение, которое 
может стать доступным в какой-то момент. Это значение обычно является результатом некоторых других вычислений:

1. Если вычисление еще не завершено, мы говорим, что `Future` не завершено (**not completed**);

2. Если вычисление завершилось со значением или с исключением, мы говорим, что будущее завершено (**completed**);

Завершение может принимать одну из двух форм:

1. Когда `Future` завершено **со значением**, мы говорим, что `Future` было успешно завершено (**successfully completed**) 
с этим значением;

2. Когда `Future` завершено **с исключением**, вызванным вычислением, мы говорим, что `Future` не получилось (**failed**) с этим исключением.

`Future[T]` имеет важное свойство - его можно назначить только один раз. Когда объекту `Future` присваивается значение 
или исключение, он становится фактически неизменным - _он никогда не может быть перезаписан._

Самый простой способ создания будущего объекта - вызвать метод `Future.apply`, который запускает асинхронное вычисление
 и возвращает будущее, в котором будет получен результат этого вычисления. Результат становится доступным после завершения будущего.

Обратите внимание, что `Future[T]` - это тип, который обозначает будущие объекты, тогда как `Future.apply` - это метод, 
который создает и планирует асинхронное вычисление, а затем возвращает объект `Future`, который будет завершен с результатом 
этого вычисления.

Это лучше всего показано на примере.

_Предположим, что мы хотим использовать гипотетический API некоторой популярной социальной сети, чтобы получить список 
друзей для данного пользователя. Мы откроем новый сеанс, а затем отправим запрос на получение списка друзей конкретного пользователя:_

```scala
    import scala.concurrent._
    import ExecutionContext.Implicits.global
    
    val session = socialNetwork.createSessionFor("user", credentials)
    val f: Future[List[Friend]] = Future {
      session.getFriends()
    }
```

Выше мы сначала импортируем содержимое пакета `scala.concurrent`, чтобы сделать тип `Future` видимым. Мы вскоре объясним 
второй импорт.

Затем мы инициализируем переменную `session`, которую будем использовать для отправки запросов на сервер, используя 
гипотетический метод `createSessionFor`. Чтобы получить список друзей пользователя, запрос должен быть отправлен по сети, 
что может занять много времени. Это иллюстрируется вызовом метода `getFriends`, который возвращает `List[Friend]`. Чтобы 
лучше использовать процессор до тех пор, пока не поступит ответ, мы не должны блокировать остальную часть программы - это 
вычисление должно планироваться асинхронно. Метод `Future.apply` делает именно это: он одновременно выполняет заданный 
вычислительный блок, в этом случае отправляет запрос на сервер и ожидает ответа.

Список друзей станет доступен в будущем `f`, как только сервер ответит.

Неудачная попытка может привести к исключению. В следующем примере значение сеанса некорректно инициализировано, поэтому 
вычисление в блоке `Future` будет вызывать исключение `NullPointerException`. Это будущее `f` затем завершилось неудачей с
 этим исключением вместо успешного завершения:
 
```scala
    val session = null
    val f: Future[List[Friend]] = Future {
      session.getFriends
    }
``` 

Импорт строки `ExecutionContext.Implicits.global` выше импортирует контекст глобального исполнения по умолчанию. Контексты 
выполнения выполняют задачи, переданные им, и вы можете рассматривать контексты выполнения как пулы потоков. Они необходимы 
для метода `Future.apply`, поскольку они обрабатывают, как и когда выполняется асинхронное вычисление. Вы можете определить 
свои собственные контексты выполнения и использовать их в `Future`, но на данный момент достаточно знать, что вы можете 
импортировать контекст выполнения по умолчанию, как показано выше.

Наш пример был основан на гипотетическом API социальной сети, где вычисление состоит из отправки сетевого запроса и 
ожидания ответа. Справедливо предложить пример с асинхронным вычислением, который вы можете попробовать из коробки. 
Предположим, у вас есть текстовый файл, и вы хотите найти позицию первого появления определенного ключевого слова. Это 
вычисление может включать блокирование, пока содержимое файла извлекается с диска, поэтому имеет смысл выполнять его 
одновременно с остальной частью вычисления.



_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Parallel-Programming/blob/master/readme.md)
