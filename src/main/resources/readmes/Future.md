## Монада Future[T]

`Future [T]` - это [монада](https://ru.wikipedia.org/wiki/Монада_(программирование)), которая обрабатывает как исключения, так и задержки,
потому что все еще эти вычисления могут потерпеть неудачу, но также они требуют времени. 
Теперь давайте посмотрим, как выглядит этот тип. И интересный метод, конечно, 
существует много вспомогательных методов, но наиболее важным методом является `onComplete`, который выполняет обратный 
вызов, который является функцией `Try[T]` для `Unit`. И это означает, что это та функция, о которой я говорил, этот 
конверт с адресами. Поэтому, когда у вас есть `Future`, когда у вас есть вычисление, которое может занять много времени, вы 
делаете обратный вызов. 
Когда это вычисление закончится, этот обратный вызов вернется вам с результатом. И этот результат может быть 
либо `обычным значением`, либо `успешным значением`, либо `исключением`. 
Мы видим, что наш хороший друг в `Try[T]` вернулся. И если вы снова посмотрите на определения Scala, и типы 
могут быть немного сложнее, но в этом суть. И, в частности, будущий колл, этот неявный контекст выполнения, вы увидите, 
что он пока недоступен, мы это проигнорируем. Через пару уроков мы поговорим об этом немного подробнее. Но пока вы просто 
импортируете `ExecutionContext.Implicits.global`, и вам не нужно беспокоиться об этом.

![alt text](https://github.com/steklopod/Timely-Effects/blob/master/src/main/resources/images/Future.png "Future")

Теперь немного о вопросе дизайна. Как только у вас есть функция, которая выполняет обратный вызов этой формы. Поэтому, 
если обратный вызов, который набрал `Try [T]` в `Unit`, это означает, что эта функция внутренне, вероятно, будет лучше сочетаться 
или будет использовать некоторые из комбинаторов, выше или функции, определенные в `Try`. Но во многих случаях вы сделаете 
лучшее совпадение, чтобы проверить, было ли ваше вычисление успешным, тогда вы делаете что-то одно или когда ваше вычисление 
потерпело неудачу, а затем вы делаете другое дело. Таким образом, этот дизайн будущего - это не единственный возможный 
дизайн. Например, что мы можем сделать, так это то, что мы можем выполнять функции там с правой стороны, которые лучше 
соответствуют onNext и onError. И передайте их отдельно в обратный вызов `O` `onComplete`, или что мы можем сделать, так это 
то, что мы можем сказать, что есть две функции, которые позволяют самим поставить их в тип и передать это. Таким образом, 
это будет выглядеть так, как если бы мы сосредоточились только на сути, поэтому первый из них будет заключаться в том, что 
onComplete будет принимать два обратных вызова один, когда функция будет успешно завершена, а другая - при сбое.


Если вы программист `JavaScript`, вы увидите, что JavaScript часто использует эту модель. Поэтому многие API-интерфейсы на 
основе JavaScript, которые занимаются асинхронностью, будут иметь два обратных вызова. Во-первых, продолжения успеха или 
иногда эти обратные вызовы также называются продолжениями. Итак, что вы увидите, это то, что они будут иметь успех, который 
является функцией от T до единицы. И продолжение продолжения, которое принимает исключение, а также возвращает единицу.
Но, конечно, мы также можем сделать эти две функции в свой собственный тип, а затем передать экземпляр этого типа. Таким 
образом, это будет тем более подход OO к этому. И я показываю вам эти альтернативы, потому что есть много языков, у многих
 библиотек есть свои подходы к решению того, какие фьючерсы и так или иначе, и хорошо идти достаточно, чтобы видеть, что
 они все равно. На самом деле суть в том, что вы предоставляете обратный вызов, который будет вызываться после подсчета
 и выделения. Поэтому, учитывая этот тип `Future[T]`, давайте адаптируем наши типы, чтобы показать, что чтение из памяти
 и особенно отправка пакета из США в Европу может занять много времени. Итак, теперь сигнатуры достигают памяти и 
получают будущее массива укусов, то есть это будет вычисление, которое занимает много времени. Поэтому мы должны 
обеспечить обратный вызов, а затем отправить в Европу - это то же самое, что и будущее массива байтов. Но в будущем, 
конечно, есть много функций более высокого порядка, определенных на нем, потому что в противном случае мы застряли бы
 в написании уродливого кода вроде этого или даже вроде бы застряли на всех, как здесь. Сначала мы читаем из памяти,
 поэтому мы возвращаемся к будущему массива байтов. И что мы можем сделать с будущим? Ну, мы можем позвонить onComplete,
 где мы должны дать ему обратный вызов. Но теперь дело в том, что происходит, когда вы получаете провал? Потому 
что onComplete, что мы там делаем? Так что этот вид немного неудачный, этот код.
 Так что же нам делать? Ну, что мы можем сделать здесь, мы можем немного отредактировать его, и мы говорим, что когда мы находимся onComplete, мы вызываем пакет, отправленный в Европу, почему вы потерпите неудачу? Да, это все еще непросто, это похоже на лучшее совпадение и много гнездования. Так что же нам теперь делать? Что такое наш друг? Что придет на помощь? Это flatMap.

Итак, теперь у нас есть монада, конструктор типов, который позволяет нам выразить тот факт, что вычисления требуют времени 
и что они могут потерпеть неудачу. Поэтому давайте использовать конструктор типа Future, чтобы сделать наши типы более 
точными. Итак, вот наш класс Socket, readFromMemory, sendToEurope и теперь вместо прямого возврата массива байтов 
`readFromMemory` вернет `Future [Array [Byte]]`. И теперь вы можете посмотреть на этот тип и сказать, что это вычисление 
займет много времени, поэтому оно вернется в будущее и что мне делать с этим будущим? Я даю ему обратный вызов, который 
будет вызываться, как только мое будущее завершится либо с исключением, либо с регулярным значением. И аналогичным 
образом для отправки пакета из США в Европу, который занял очень много времени. Таким образом, также, тип становится 
будущим массива байтов.
Теперь, как и в случае с `Try [T]`, код становится довольно беспорядочным, потому что вызов чтения из памяти прост, 
потому что мы получаем будущее массива байтов. Но что нам теперь делать? Теперь нам нужно вернуться к onComplete.
Но onComplete взял обратный вызов, который взял `Try [T]` для `Unit`. Но мы хотим, чтобы мы получили подтверждение, 
что будущий массив байтов. Так что это довольно проблематично, мы не можем написать это так, потому что здесь правая 
сторона будет иметь тип единицы. В то время как мы хотим, это будущее массива байтов. Итак, мы видим, что компилятор 
жалуется, есть красные squiggles. Вы никогда не хотите видеть эти красные squiggles в своем коде, но что мы можем 
сделать? Итак, давайте попробуем немного преувеличивать этот код, чтобы мы могли вернуть будущий массив укусов. Итак, 
давайте снова будем читать из памяти, а затем мы скажем, когда пакет завершится, мы получим обратный вызов. Мы получаем 
подтверждение, но теперь это подтверждение правильного типа вложенно в это завершение, это проблема с обратными вызовами. 
Ваш код все запутался наизнанку, это не очень удобно. Но давайте перейдем к следующей лекции, когда мы поговорим о 
функциях более высокого порядка в будущем. Давайте просто немного поразмышляем о том, как мы можем построить будущее и 
так далее. Итак, вот как вы строите будущее. Наше будущее принимает тело, вычисление, и здесь вы видите это по функции 
имени, стрелка Т. И он принимает неявный контекст выполнения, а затем возвращает будущее. И снова, не беспокойтесь о 
контексте выполнения, потому что мы импортируем неявный глобальный контекст выполнения. Но что делает этот конструктор, 
он запускает асинхронное вычисление и сразу возвращает будущее, с которого вы можете зарегистрировать обратный вызов, 
когда будет завершено будущее. Важно отметить, что вы можете, конечно, предоставить несколько обратных вызовов в этом будущем.
И поведение будущего заключается в том, что этот обратный вызов вызывается не более одного раза, потому что вычисление 
никогда не завершится. Но когда он заканчивается, он называется ровно один раз со значением.
И если конкурс уже завершен, и вы добавляете новый обратный вызов, вызов `callback` будет вызван немедленно. Итак, вот 
небольшой пример. Мы создаем три сообщения электронной почты, а затем читаем из памяти и будущего массива байтов. И это 
определяется следующим образом: мы собираемся взять электронное письмо из очереди, сериализуем его, а затем возвращаем 
двоичное сообщение. Это чтение из памяти, но теперь обратите внимание, что всякий раз, когда я помещаю обратный вызов 
этому чтению из памяти, код в этом теле будет выполняться только один раз. Так что не так, когда вы регистрируете два 
обратных вызова, эти два письма будут прочитаны, так что это важно. Итак, вот тело с побочными эффектами, но для каждого 
обратного вызова побочный эффект будет происходить только один раз. Так что это очень важно с будущим.
Большое вам спасибо, и увидим вас в следующей лекции, где мы поговорим о функциях более высокого порядка на фьючерсах.

![alt text](https://github.com/steklopod/Timely-Effects/blob/master/src/main/resources/images/future-thread.jpg "Future 2")


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._


[<= содержание](https://github.com/steklopod/Timely-Effects/blob/master/readme.md)
