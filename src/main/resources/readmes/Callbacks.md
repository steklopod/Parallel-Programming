### Обратные вызовы (Callbacks)

Теперь мы знаем, как начать асинхронное вычисление для создания нового будущего значения, но мы не показали, как использовать 
результат, когда он станет доступным, чтобы мы могли сделать что-то полезное с ним. Нас часто интересует результат вычислений, 
а не только его побочные эффекты.

Во многих будущих реализациях, когда клиент будущего заинтересован в его результате, он должен блокировать свои собственные 
вычисления и ждать, пока будущее не будет завершено, - только тогда он сможет использовать ценность будущего для продолжения 
собственного вычисления. Хотя это разрешено API-интерфейсом Scala `Future`, как мы покажем ниже, с точки зрения 
производительности **лучший не блокирующий способ сделать это, зарегистрировать обратный вызов на будещее**. Этот обратный 
вызов вызывается асинхронно после завершения будущего. Если будущее будет завершено при регистрации обратного вызова, 
то обратный вызов может быть выполнен либо асинхронно, либо последовательно в одном потоке.

![alt text](https://github.com/steklopod/Parallel-Programming/blob/master/src/main/resources/images/FutureStatesAndValues.jpeg)

Наиболее общей формой регистрации обратного вызова является использование метода `onComplete`, который выполняет функцию 
обратного вызова типа `Try[T] => U`. Обратный вызов применяется к значению типа `Success[T]`, если будущее завершается 
успешно или к значению типа `Failure[T]` в противном случае.

`Try[T]` аналогичен `Option[T]` или `Either[T, S]`, что  является монадой, потенциально содержащей значение какого-либо типа. 
Тем не менее, он был специально разработан для того, чтобы либо удерживать значение, либо какой-либо объект, который можно 
выбросить. Где `Option[T]` может быть либо значением (т.е. `Some[T]`), либо вообще не иметь значения (т.е. `None`), 
`Try[T]` - это `Success[T]`, когда он содержит значение и в противном случае `Failure[T]`, который содержит исключение. 
`Failure[T]` содержит больше информации, чем просто простое `None`, говоря, почему значение отсутствует. В то же время 
вы можете придумать `Try[T]` как специальную версию `Either[Throwable, T]`, специализированную для случая, когда левое 
значение является `Throwable`.

![alt text](https://github.com/steklopod/Parallel-Programming/blob/master/src/main/resources/images/either.png)

Возвращаясь к нашему примеру в социальной сети, предположим, что мы хотим получить список наших последних сообщений и 
отобразить их на экране. Мы делаем это, вызывая метод `getRecentPosts`, который возвращает `List[String]` - список последних 
текстовых сообщений:

>onComplete
```scala
    import scala.util.{Success, Failure}
    
    val f: Future[List[String]] = Future {
      session.getRecentPosts
    }
    
    f onComplete {
      case Success(posts) => for (post <- posts) println(post)
      case Failure(t) => println("An error has occurred: " + t.getMessage)
    }
```

Метод `onComplete` является общим в том смысле, что он позволяет клиенту обрабатывать результат как неудачных, так и 
успешных будущих вычислений. В случае, когда нужно обрабатывать только успешные результаты, можно использовать обратный вызов `foreach`:

>foreach
```scala
    val f: Future[List[String]] = Future {
      session.getRecentPosts
    }
    
    f foreach { posts =>
      for (post <- posts) println(post)
    }
```

`Future` обеспечивают чистый способ обработки только неудачных результатов с использованием неудачной проекции(`failed` projection),
 которая преобразует `Failure[Throwable]` в `Success[Throwable]`.

Возвращаясь к предыдущему примеру с поиском первого появления ключевого слова, вы можете распечатать позицию ключевого слова 
на экране:

```scala
    val firstOccurrence: Future[Int] = Future {
      val source = scala.io.Source.fromFile("myText.txt")
      source.toSeq.indexOfSlice("мое Ключевое Слово")
    }
    
    firstOccurrence onComplete {
      case Success(idx) => println("Ключевое слово сначала появляется в позиции: " + idx)
      case Failure(t) => println("Не удалось обработать файл: " + t.getMessage)
    }
```

В методах `onComplete` и `foreach` оба имеют тип типа результата, что означает, что вызовы этих методов не могут быть 
связаны в цепь. Обратите внимание, что эта конструкция не предполагает, что цепные вызовы могут означать 
заказ на выполнение зарегистрированных обратных вызовов (обратные вызовы, зарегистрированные в одном и том же будущем, 
являются неупорядоченными).

Тем не менее, мы должны теперь прокомментировать, **когда** именно вызван обратный вызов. Поскольку это требует, чтобы искомое значение 
в будущем было доступно, его можно вызвать только после того, как будущее будет завершено. Тем не менее, нет гарантии, что 
оно будет вызвано потоком, который завершил будущее, или потоком, который создал обратный вызов. Вместо этого обратный 
вызов выполняется каким-то потоком, через какое-то время после завершения будущего объекта. Мы говорим, что обратный вызов 
выполняется **в конечном итоге**.

Кроме того, порядок, в котором выполняются обратные вызовы, не предопределен, даже между разными прогонами того же приложения.
 Фактически, обратные вызовы могут не вызываться последовательно один за другим, но могут выполняться одновременно.
  Это означает, что в следующем примере переменная `totalA` не может быть установлена ​​на правильное количество строчных  и 
  верхних регистров `a` символов из вычисленного текста.

```scala
    @volatile var totalA = 0
    
    val text = Future {
      "na" * 16 + "BATMAN!!!"
    }
    
    text foreach { txt =>
      totalA += txt.count(_ == 'a')
    }
    
    text foreach { txt =>
      totalA += txt.count(_ == 'A')
    }
```

Выше два обратных вызова могут выполняться один за другим, и в этом случае переменная `totalA` содержит ожидаемое значение 
`18`. Однако они также могут выполняться одновременно, поэтому `totalA` может быть либо `16`, либо `2`, так как `+=` не 
является атомарным _(т.е. состоит из шага чтения и записи, который может чередоваться друг с другом с другими чтениями и записью)_.

>Для полноты здесь перечислены семантики обратных вызовов:

1. Регистрация обратного вызова `onComplete` на будущем гарантирует, что соответствующее закрытие будет вызвано после завершения будущего;

2. Регистрация обратного вызова `foreach` имеет ту же семантику, что и `onComplete`, с той разницей, что замыкание вызывается 
только в том случае, если будущее завершено успешно;

3. Регистрация обратного вызова в будущем, которое уже завершено, приведет к тому, что обратный вызов будет выполнен в 
конечном итоге (как подразумевается 1);

4. Если в будущем зарегистрировано несколько обратных вызовов, порядок, в котором они выполняются, не определен. Фактически, 
обратные вызовы могут выполняться одновременно друг с другом. Однако конкретная реализация `ExecutionContext` может 
привести к определенному порядку;

5. В случае, если некоторые вызовы вызывают исключение, другие обратные вызовы выполняются независимо;

6. В случае, если некоторые из обратных вызовов никогда не завершаются (например, обратный вызов содержит бесконечный цикл), 
другие обратные вызовы могут вообще не выполняться. В этих случаях потенциально блокирующий обратный вызов должен 
использовать конструкцию блокировки;

7. После выполнения обратные вызовы удаляются из будущего объекта, поэтому он имеет право на GC.

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Parallel-Programming/blob/master/readme.md)
