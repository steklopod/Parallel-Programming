### Обратные вызовы (Callbacks)

Теперь мы знаем, как начать асинхронное вычисление для создания нового будущего значения, но мы не показали, как использовать 
результат, когда он станет доступным, чтобы мы могли сделать что-то полезное с ним. Нас часто интересует результат вычислений, 
а не только его побочные эффекты.

Во многих будущих реализациях, когда клиент будущего заинтересован в его результате, он должен блокировать свои собственные 
вычисления и ждать, пока будущее не будет завершено, - только тогда он сможет использовать ценность будущего для продолжения 
собственного вычисления. Хотя это разрешено API-интерфейсом Scala `Future`, как мы покажем ниже, с точки зрения 
производительности лучший не блокирующий способ сделать это, зарегистрировать обратный вызов на будещее. Этот обратный 
вызов вызывается асинхронно после завершения будущего. Если будущее будет завершено при регистрации обратного вызова, 
то обратный вызов может быть выполнен либо асинхронно, либо последовательно в одном потоке.

![alt text](https://github.com/steklopod/Parallel-Programming/blob/master/src/main/resources/images/FutureStatesAndValues.jpeg)

Наиболее общей формой регистрации обратного вызова является использование метода `onComplete`, который выполняет функцию 
обратного вызова типа `Try[T] => U`. Обратный вызов применяется к значению типа `Success[T]`, если будущее завершается 
успешно или к значению типа `Failure[T]` в противном случае.

`Try[T]` аналогичен `Option[T]` или `Either[T, S]`, что  является монадой, потенциально содержащей значение какого-либо типа. 
Тем не менее, он был специально разработан для того, чтобы либо удерживать значение, либо какой-либо объект, который можно 
выбросить. Где `Option[T]` может быть либо значением (т.е. `Some[T]`), либо вообще не иметь значения (т.е. `None`), 
`Try[T]` - это `Success[T]`, когда он содержит значение и в противном случае `Failure[T]`, который содержит исключение. 
`Failure[T]` содержит больше информации, чем просто простую нить, говоря, почему значение не существует. В то же время 
вы можете придумать `Try[T]` как специальную версию `Either[Throwable, T]`, специализированную для случая, когда левое 
значение является `Throwable`.

![alt text](https://github.com/steklopod/Parallel-Programming/blob/master/src/main/resources/images/either.png)

Возвращаясь к нашему примеру в социальной сети, предположим, что мы хотим получить список наших последних сообщений и 
отобразить их на экране. Мы делаем это, вызывая метод `getRecentPosts`, который возвращает `List[String]` - список последних 
текстовых сообщений:

```scala
    import scala.util.{Success, Failure}
    
    val f: Future[List[String]] = Future {
      session.getRecentPosts
    }
    
    f onComplete {
      case Success(posts) => for (post <- posts) println(post)
      case Failure(t) => println("An error has occurred: " + t.getMessage)
    }
```

Метод `onComplete` является общим в том смысле, что он позволяет клиенту обрабатывать результат как неудачных, так и 
успешных будущих вычислений. В случае, когда нужно обрабатывать только успешные результаты, можно использовать обратный вызов `foreach`:

```scala
    val f: Future[List[String]] = Future {
      session.getRecentPosts
    }
    
    f foreach { posts =>
      for (post <- posts) println(post)
    }
```

`Future` обеспечивают чистый способ обработки только неудачных результатов с использованием неудачной проекции(`failed` projection),
 которая преобразует `Failure[Throwable]` в `Success[Throwable]`. Пример этого показан в разделе ниже о (прогнозах)[https://docs.scala-lang.org/overviews/core/futures.html#projections].

Возвращаясь к предыдущему примеру с поиском первого появления ключевого слова, вы можете распечатать позицию ключевого слова 
на экране:

```scala
    val firstOccurrence: Future[Int] = Future {
      val source = scala.io.Source.fromFile("myText.txt")
      source.toSeq.indexOfSlice("мое Ключевое Слово")
    }
    
    firstOccurrence onComplete {
      case Success(idx) => println("Ключевое слово сначала появляется в позиции: " + idx)
      case Failure(t) => println("Не удалось обработать файл: " + t.getMessage)
    }
```

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Parallel-Programming/blob/master/readme.md)
