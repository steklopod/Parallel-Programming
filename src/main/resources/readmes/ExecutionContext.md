### Введение

Фьючерсы дают возможность рассуждать о выполнении многих операций параллельно - эффективным и неблокирующим способом. 
[Future](https://www.scala-lang.org/api/current/scala/concurrent/Future.html) является объектом-заполнителем (монадой) для значения, 
которое может еще не существовать. Составление параллельных задач приводит к более быстрому, асинхронному, неблокирующему 
параллельному коду.

По умолчанию фьючерсы и обещания (`promise`s) не блокируются, используя обратные вызовы вместо типичных операций блокировки. 
Чтобы упростить использование обратных вызовов как синтаксически, так и концептуально, Scala предоставляет комбинаторы, 
такие как `flatMap`, `foreach` и `filter`, используемые для создания фьючерсов неблокирующим способом. Блокировка 
по-прежнему возможна - для случаев, когда это абсолютно необходимо, фьючерсы могут быть заблокированы (хотя это не рекомендуется).

Типичный `Future` выглядит так:

```scala
    val inverseFuture: Future[Matrix] = Future {
      fatMatrix.inverse() // неблокирующее долговременное вычисление
    }(executionContext)
```

Или более идиоматически:

```scala
    implicit val ec: ExecutionContext = ...
    val inverseFuture : Future[Matrix] = Future {
      fatMatrix.inverse()
    } // ec неявно передается
```

Оба фрагмента кода делегируют выполнение `fatMatrix.inverse()` в `ExecutionContext` и воплощают результат вычисления в `inverseFuture`.

### Контекст выполнения (Execution Context)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/Parallel-Programming/blob/master/readme.md)